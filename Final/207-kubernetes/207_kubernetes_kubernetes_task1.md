## 一、项目的基本背景和发展历程介绍

- ### 技术类型

Kubernetes，也称为K8s，是一个开源系统，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful），Kubernetes提供了应用部署、规划、更新、维护的一种机制。作为Google开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。在Kubernetes中，可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。从2014年发展至今，业界已将 Kubernetes技术视为容器编排调度方案的事实标准。

Kubernetes旨在消除编排物理/虚拟计算、网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在 以容器为中心的基础上进行自助运营。Kubernetes 也提供稳定、兼容的基础（平台），用于构建定制化的workflows 和更高级的自动化任务。Kubernetes 还具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。

在介绍Kubernetes核心技术之前，需要先了解Kubernetes的几个专业术语的意思。Pod是Kubernetes里最小的资源管理对象，Pod运行在Node节点上，容器运行在Pod里，Pod里包含一个根容器和一个或多个业务容器，一般来说，紧密相关联的几个业务进程会被以不同的容器镜像的形式放在同一个Pod里。Node是kubernetes集群中的工作节点，就是负责工作的。Node可以是任何形式的计算设备，能装k8s的集群代理程序，它都可以作为整个k8s集群一个成员。Service简称(Svc)，Svc就是一个“微服务”，Svc定义了一个服务的访问入口地址，前端应用（Pod）通过这个入口地址访问其背后的一组由Pod副本组成的集群实例。Service与其后端的Pod之间通过Label Selector实现“无缝对接”，Replication Controller（简称RC）的作用是通过满足要求的Pod副本数，保证Svc的服务能力和服务质量始终处于预期的标准。

从整理架构看，Kubernetes包含Master组件(APIs, scheduler, etcd)，Node节点和cloud端。Master中包含负责提供API服务的组件kube-apiserver、作为后台数据库的etcd、监听组件kube-scheduler、运行控制器的组件kube-controller-manager。Node节点中包括运行在各个节点的客户端的kubelet、运行在各个节点的网络代理组件kube-proxy、支持运行容器底层环境的软件（Docker）。Cloud端作为集群外部的附加能力，通过与cloud-controller-manager组件对接，扩展k8s集群云上动态扩展的特性。

Kubernetes Master是集群的主要控制单元，用于管理其工作负载并指导整个系统的通信。其中，etcd是一个响应快、分布式、一致的Key-value存储，因为它是分布式的，故可以运行多个etcd实例来获取高可用性和更好的性能，唯一能直接和etcd通信的是Kubernetes的API服务器，所有其他组件通过API服务器间接地读取，写入数据到etcd，并且etcd是Kubernetes存储集群状态和元数据的唯一的地方。Kubernetes API服务器作为中心组件，其他组件或者客户端都会去调用它，以RESTful API的形式提供了可以查询、修改集群状态的CRUD(Create, Read, Update, Delete)接口，将状态存储到etcd中，API服务器除了提供一种一致的方式将对象存储到etcd，也对这些对象做校验，这样客户端就无法存入非法的对象(直接写入存储的话是有可能的)，除了检验，还会处理乐观锁，这样对于并发更新的情况,对对象做更改就不会被其他客户端覆盖。调度器利用API服务器的监听机制等待新创建的pod,然后给每个新的、没有节点集的pod分配节点。调度器不会命令选中的节点去运行pod，调度器做的就是通过API服务器更新pod的定义，然后API服务器再去通知Kubelet该pod已经被调度过，当目标节点上的Kubelet发现该pod被调度到本节点，他就会创建并且运行pod的容器。API服务器只做了存储资源到etcd和通知客户端有变更的工作，调度器则只是给pod分配节点，所以需要有活跃的组件确保系统真实状态朝API服务器定义的期望的状态收敛，这个工作由控制器管理器里的控制器来实现。

关于Node节点，其中，Kubelet是负责所有运行在工作节点上内容的组件，它第一个任务就是在API服务器中创建一个Node资源来注册该节点，然后需要持续监控API服务器是否把该节点分配给pod再启动pod容器。具体实现方式是告知配置好的容器进行时来从特定容器镜像运行容器,Kubelet随后持续监控运行的容器，向API服务器报告他们的状态,事件和资源消耗，负责管理pods和他们的容器、images镜像、卷组。Kubelet也是运行容器存活探针的组件，当探针报错时它会重启容器。当pod从API服务器删除时，Kubelet终止容器，并通知服务器pod已经被终止了。每个工作节点都会运行kube-proxy，用于确保客户端可以通过Kubernetes API连接到你定义的服务。kube-proxy确保对服务IP和端口的连接最终能到达支持服务的某个pod处。如果有多个pod支撑一个服务，那么kube-proxy会发挥对pod的负载均衡作用。docker用于运行容器。

- ### 版本发布历史

#### 版本1.2

1.2系列包括：版本1.2.0，版本1.2.1，版本1.2.2，版本1.2.3，版本1.2.4，版本1.2.5，版本1.2.6，版本1.2.7

#### 版本1.3

1.3系列包括：版本1.3.10、版本1.3.9、版本1.3.8、版本1.3.7、版本1.3.6、版本1.3.5、版本1.3.4、版本1.3.3、版本1.3.2、版本1.3.1、版本1.3.0、版本1.3.0 中包含的早期版本

#### 版本1.4

1.4系列包括：版本1.4.12、版本1.4.9、版本1.4.8版本1.4.7、版本1.4.6、版本1.4.5、版本1.4.4、版本1.4.3、版本1.4.2、版本1.4.0、版本1.4.0 中包含的早期版本

#### 版本1.5

1.5系列包括：版本1.5.8、版本1.5.7、版本1.5.6、版本1.5.5、版本1.5.4、版本1.5.3、版本1.5.2、版本1.5.1、版本1.5.0、版本1.5.0 中包含的早期版本。

#### 版本1.6

1.6系列包括：版本1.6.13、版本1.6.12、版本1.6.11、版本1.6.10、版本1.6.9、版本1.6.8、版本1.6.7、版本1.6.6、版本1.6.5、版本1.6.4、版本1.6.3、版本1.6.2、版本1.6.1、版本1.6.0、版本1.6.0 中包含的早期版本。

#### 版本1.7

1.7系列包括：版本1.7.16、版本1.7.15、版本1.7.144版本1.7.13、版本1.7.12、版本1.7.11、版本1.7.10、版本1.7.9、版本1.7.8、版本1.7.7、版本1.7.6、版本1.7.5、版本1.7.4、版本1.7.3、版本1.7.2、版本1.7.1、版本1.7.0、版本1.7.0 中包含的早期版本。

#### 版本1.8

1.8系列包括：版本1.8.15、版本1.8.14、版本1.8.13、版本1.8.12、版本1.8.11、版本1.8.10、版本1.8.9、版本1.8.8、版本1.8.7、版本1.8.6、版本1.8.5、版本1.8.4、版本1.8.3、版本1.8.2、版本1.8.1、版本1.8.0、版本1.8.0 中包含的早期版本。

#### 版本1.9

1.9系列包括：版本1.9.11、版本1.9.10、版本1.9.9、版本1.9.8、版本1.9.7、版本1.9.6、版本1.9.5、版本1.9.4、版本1.9.3、版本1.9.2、版本1.9.1、版本1.9.0、版本1.9.0 中包含的早期版本。

#### 版本1.10

1.10系列包括：版本1.10.13、版本1.10.12、版本1.10.11、版本1.10.10、版本1.10.9、版本1.10.8、版本1.10.7、版本1.10.6、版本1.10.5、版本1.10.4、版本1.10.3、版本1.10.2、版本1.10.1、版本1.10.0、版本1.10.0 中包含的早期版本。

#### 版本1.11

1.11系列包括：版本1.11.10、版本1.11.9、版本1.11.8、版本1.11.7、版本1.11.6、版本1.11.5、版本1.11.4、版本1.11.3、版本1.11.2、版本1.11.1、版本1.11.0、版本1.11.0 中包含的早期版本。

#### 版本1.12

1.12系列包括：版本1.12.10、版本1.12.9、版本1.12.8、版本1.12.7、版本1.12.6、版本1.12.5、版本1.12.4、版本1.12.3、版本1.12.2、版本1.12.1、版本1.12.0、版本1.12.0 中包含的早期版本。

#### 版本1.13

1.13系列包括：版本1.13.12、版本1.13.11、版本1.13.10、版本1.13.9、版本1.13.8、版本1.13.7、版本1.13.6、版本1.13.5、版本1.13.4、版本1.13.3、版本1.13.2、版本1.13.1、版本1.13.0、版本1.13.0 中包含的早期版本。

#### 版本1.14

1.14系列包括：版本1.14.10、版本1.14.9、版本1.14.8、版本1.14.7、版本1.14.6、版本1.14.5、版本1.14.4、版本1.14.3、版本1.14.2、版本1.14.1、版本1.14.0、版本1.14.0 中包含的早期版本。

#### 版本1.15

1.15系列包括：版本1.15.12、版本1.15.11、版本1.15.10、版本1.15.9、版本1.15.8、版本1.15.7、版本1.15.6、版本1.15.5、版本1.15.4、版本1.15.3、版本1.15.2、版本1.15.1、版本1.15.0、版本1.15.0 中包含的早期版本。

#### 版本1.16

1.16系列包括：版本1.16.15、版本1.16.14、版本1.16.13、版本1.16.12、版本1.16.11、版本1.16.10、版本1.16.9、版本1.16.8、版本1.16.7、版本1.16.6、版本1.16.5、版本1.16.4、版本1.16.3、版本1.16.2、版本1.16.1、版本1.16.0、版本1.16.0 中包含的早期版本。

#### 版本1.17

1.17系列包括：版本1.17.17、版本1.17.16、版本1.17.15、版本1.17.14、版本1.17.13、版本1.17.12、版本1.17.11、版本1.17.10、版本1.17.9、版本1.17.8、版本1.17.7、版本1.17.6、版本1.17.5、版本1.17.4、版本1.17.3、版本1.17.2、版本1.17.1、版本1.17.0、版本1.17.0 中包含的早期版本。

#### 版本1.18

1.18系列包括：版本1.18.20、版本1.18.19、版本1.18.18、版本1.18.17、版本1.18.16、版本1.18.15、版本1.18.14、版本1.18.13、版本1.18.12、版本1.18.11、版本1.18.10、版本1.18.9、版本1.18.8、版本1.18.7、版本1.18.6、版本1.18.5、版本1.18.4、版本1.18.3、版本1.18.2、版本1.18.1、版本1.18.0、版本1.18.0 中包含的早期版本。

#### 版本1.19

1.19系列包括：版本1.19.16、版本1.19.15、版本1.19.14、版本1.19.13、版本1.19.12、版本1.19.11、版本1.19.10、版本1.19.9、版本1.19.8、版本1.19.7、版本1.19.6、版本1.19.5、版本1.19.4、版本1.19.3、版本1.19.2、版本1.19.1、版本1.19.0、版本1.19.0 中包含的早期版本。

#### 版本1.20

1.20系列包括：版本1.20.15、版本1.20.14、版本1.20.13、版本1.20.12、版本1.20.11、版本1.20.10、版本1.20.9、版本1.20.8、版本1.20.7、版本1.20.6、版本1.20.5、版本1.20.4、版本1.20.3、版本1.20.2、版本1.20.1、版本1.20.0、版本1.20.0 中包含的早期版本。

#### 版本1.21

1.21系列包括：版本1.21.14、版本1.21.13、版本1.21.12、版本1.21.11、版本1.21.10、版本1.21.9、版本1.21.8、版本1.21.7、版本1.21.6、版本1.21.5、版本1.21.4、版本1.21.3、版本1.21.2、版本1.21.1、版本1.21.0、版本1.21.0 中包含的早期版本。

#### 版本1.22

1.22系列包括：版本1.22.11、版本1.22.10、版本1.22.9、版本1.22.8、版本1.22.7、版本1.22.6、版本1.22.5、版本1.22.4、版本1.22.3、版本1.22.2、版本1.22.1、版本1.22.0、版本1.22.0 中包含的早期版本。

#### 版本1.23

1.23系列包括：版本1.23.8、版本1.23.7、版本1.23.6、版本1.23.5、版本1.23.4、版本1.23.3、版本1.23.2、版本1.23.1、版本1.23.0、版本1.23.0 中包含的早期版本。

#### 版本1.24

1.24系列包括：版本1.24.2、版本1.24.1、版本1.24.0、版本1.24.0 中包含的早期版本。

#### 版本1.25

1.25系列包括：版本1.25.0-阿尔法.1

- ### 主要贡献者的构成（国家、区域和组织等）

提交1000次以上的贡献者：

Jordan Liggitt

1839次提交，来自美国， 谷歌高级工程师 

Wojciech Tyczynski

1443次提交，来自波兰， 就职于谷歌

Clayton Coleman 

1364次提交，来自北卡罗来纳州，Kubernetes 维护者和通用修复师

David Eads

1273次提交，来自北卡罗来纳州罗利，就职于红帽 OpenShift

Stefan Schimanski

1093次提交，来自德国，就职于红帽 OpenShift

Daniel Smith

1090次提交，来自内华达州，就职于谷歌

Tim Hockin

1075次提交，来自美国，就职于谷歌

Brendan Burns

1027次提交，来自华盛顿州西雅图，就职于微软

- ### CI/CD 的使用

Kubernetes是一个用于容器调度的开源平台，在动态环境中管理容器的生命周期。Kubernetes具有可移植、可扩展和可伸缩的特性。当下使用Kubernetes加CI/CD（持续集成/持续交付）已经是非常普遍的组合。使用CI/CD工具部署云原生应用，能够简化开发和部署的每个阶段。将云原生应用的开发与CI/CD集成，可以使其更加健壮。与传统的VM交付对比，Kubernetes的持续交付效率更高。在需要更新和变更时不需要让整个应用先停下来。

基于Kubernetes的CI/CD流水线通常包含4个主要的组件：版本控制系统Version Control System、CI系统、Docker仓库、Kubernetes集群。各个部件的协调和自动化能使软件交付做到无缝、连续。

Kubernetes正在迅速流行起来，所有的工具都在升级以与Kubernetes集成。流行的Kubernetes CI/CD工具有：Helm、Ksonnet和Jsonnet、Draft、Jenkins X、CircleCI、Travis、GitLab、Weave Could、Spinnaker、Codefresh。

Helm是Kubernetes最知名的包装管理器之一。它使用“charts”（图表），chart是Kubernetes包和应用程序需要的任何其他依赖项的定义。当你从命令行调用chart时，Helm为Kubernetes部署创建YAML文件，然后将它们添加到集群中。Helm是开源的，这意味着我们可以为自己的组织下载、更改和使用charts。Helm最大的优点是，它使复杂应用的部署更具可移植性。Helm还支持自动回滚，并且对开发人员来说更容易理解。但Helm的缺点就是很难搭建和维护。

Ksonnet（构建于JSON模板语言Jsonnet之上的）是一个配置管理工具。它提供了一种打包Kubernetes资源的方法，随后可用于创建部署所需的配置文件。Ksonnet是基于命令行界面的，而Jsonnet作为一种数据模板语言，是用来描述应用程序的。该工具的优点是，熟悉JSON的开发人员可以轻松使用JSON Net来部署他们的应用程序。然而，使用JSON和使用Jsonnet还是有一些区别的，对于开发人员来说也就存在学习成本。

Draft由微软开发的，是一个在Kubernetes上创建基于云的应用的部署工具。当代码经过持续集成后，Draft可以用来生成Docker镜像。还可以使用它来创建Helm图表，生成基于Kubernetes的应用的YAML文件。该工具的优势在于，可以将其与Helm结合使用，打包并部署应用程序。缺点是它需要大量的配置。

Jenkins X是Kubernetes部署中比较流行和强大的CI工具之一。作为一款开源的自动化工具，带有用于CI的内置插件，它由Java编写的。可以使用Jenkins来持续构建和测试软件项目，这样可以更容易地对项目进行更改。同时，可以使用此工具通过集成大量测试和部署技术来持续交付项目。尽管这是个功能强大的工具，但同时也是比较复杂，容易出错的工具。

CircleCI是另一个持续集成和交付工具。它是一个基于云的工具，包括一个用于Kubernetes自动部署的API。由于CircleCI是基于云的，所以不需要专门的服务器。CircleCI的优势在于，它使用了许多测试方法，如单元测试、集成测试和部署前的功能测试。该工具的缺点是，它缺乏使它成为一个完整CD流水线的所有部件。

Travis是一款商业CI工具，这点不像Jenkins。我们可以使用该工具注册、链接代码仓库、构建以及测试应用。还可以将该工具与其他常见的云仓库集成，如Bitbucket和GitHub。Travis是一个基于云计算的工具，不需要专用服务器。该工具允许我们在不同操作系统、不同机器上进行测试。Travis对于开源项目是免费的，但是对于商业项目需要订阅，每个企业项目大概69美元/每月。

GitLab是一个基于Web的工具，具有CI/CD流水线的特性。除了CI/CD部署工具外，它还拥有自己的代码库，其中包含wiki、代码审查、问题跟踪。GitLab是一个开源平台，可以毫不费力地在一台服务器上处理近25,000个用户。它还内置自动部署Kubernetes组件，并支持Helm图表。

Weave Cloud是一个CD工具，可以让你快速监控和管理Docker容器。它还提供了一种快速设置CI/CD流水线和Kubernetes集群的方法。它允许我们以更快的速度启动、更新和回滚来部署应用程序。该工具使用Git作为声明式基础设施和应用的唯一信任来源。缺点是它需要相当多的配置才能正常工作。

Spinnaker是Netflix开发的一款开源工具。它管理流水线和部署工作，也支持Helm图表。它是一个开源的、跨多云的工具，提供了非常高效的持续交付。缺点是，这个工具最初是为了支持VM而不是为Kubernetes构建的，因此设置起来有点复杂。

Codefresh是一个CD/CD流水线工具，也支持Helm图表。它允许我们使用自己的CI和镜像仓库。它帮助我们构建一个简单但功能强大的CI/CD流水线。它附带了一套广泛的插件，帮助我们集成我们想要的工具。缺点是，第三方工具是用它们的图形用户界面设置的，使得流水线增加了更多的复杂性。同时，Codefresh是一款商业工具，其价格从每月34美元起。

- ### 其他有价值的信息

kubernetes与docker的关系：

官方定义里，Docker是一个开源的应用容器引擎，开发者可以打包他们的应用及依赖到一个可移植的容器中，发布到流行的Linux机器上，也可实现虚拟化。k8s是一个开源的容器集群管理系统，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。

传统的虚拟技术，在将物理硬件虚拟成多套硬件后，需要再每套硬件上都部署一个操作系统，接着在这些操作系统上运行相应的应用程序。而Docker容器内的应用程序进程直接运行在宿主机(真实物理机)的内核上，Docker引擎将一些各自独立的应用程序和它们各自的依赖打包，相互独立直接运行于未经虚拟化的宿主机硬件上，同时各个容器也没有自己的内核，显然比传统虚拟机更轻便。 每个集群有多个节点，每个节点可，我们的kuberbete就是管理这些应用程序所在的小运行环境（container）而生。

Docker是应用最广泛的容器技术，它通过打包镜像、启动容器来创建服务。然而，随着应用的日益复杂，容器的数量也不断增加，由此衍生出管理运维容器这一重要问题。随着云计算的发展，容器的漂移也是云端最大的挑战。k8s正是在这种业务的驱动下，提出了一套全新的基于容器技术的分布式架构领先方案，这是容器技术领域中一个重大突破和创新。

## 二、项目的历史轨迹分析

基于给出的数据，完成项目 **2015年/创建 - 2021** 期间的以下数据分析任务：

*PS：给出的数据包含2022年的日志，但数据分析的时间节点只到2021年年底，2022年的不纳入统计范围*

1. 每月新增 Star 和 Fork 的个数

 ![image-20220629220053409](https://raw.githubusercontent.com/dcxr969/picgooo/master/img/202206292201998.png)

2. 每月打开 Issue 和 关闭 Issue 的个数

![image-20220629220110475](https://raw.githubusercontent.com/dcxr969/picgooo/master/img/202206292201955.png)

3. 每月打开 PR 和**合入** PR 的个数（注意，关闭 PR 不等于合入）

![image-20220629220132933](https://raw.githubusercontent.com/dcxr969/picgooo/master/img/202206292201789.png)

4. 每月在仓库中活跃（只要有日志产生就算）的不同开发者（也就是一个GitHub账号）总数

![image-20220629220152680](https://raw.githubusercontent.com/dcxr969/picgooo/master/img/202206292201402.png)

5. Issue 从打开到关闭的平均时长和中位数（单位：天)

![image-20220629220229470](https://raw.githubusercontent.com/dcxr969/picgooo/master/img/202206292202355.png)

6. PR 从打开到合入的平均时长和中位数（单位：天）

![image-20220629220248835](https://raw.githubusercontent.com/dcxr969/picgooo/master/img/202206292202980.png)

7. Issue和PR从打开到第一次有人回复（非本人回复）的平均时长和中位数（单位：天）

![image-20220629220312738](https://raw.githubusercontent.com/dcxr969/picgooo/master/img/202206292203737.png)





## 三、结合期中分析的归档项目，对比分析活跃/归档项目

期中分析的归档项目为Marp，是一个简单的Markdown演示文稿编写器。

- 项目基础数据（2.1/2.2/2.3）的变化趋势

**Marp每月新增 Star 和 Fork 的个数**

  

  ![image-20220515144149013](https://raw.githubusercontent.com/dcxr969/OSSDev2022/main/img/202205151442207.png)

**kubernetes每月新增 Star 和 Fork 的个数**

  ![image-20220629190733778](https://raw.githubusercontent.com/dcxr969/picgooo/master/img/202206291907657.png)

**Marp**：star和fork数呈现出一致性，在2016年5月创始之初到2016年7月之间呈现出一个激增的趋势，并在2016年7月达到顶峰。在此之后star个数在100左右，fork数在10左右，大体呈现出缓慢下降的趋势，仅在2016年11月和2019年2月出现了小的峰值波动。从中可以看出该项目的受关注程度在不断下降。

**kubernetes**：star数波动较为明显，fork数基本保持稳定，在2015年1月到2019年3月之间，star数呈现波动上涨，由500上涨到1500左右。在2019年3月之后，呈现出波动下降的趋势，并在2021年9月出现明细下跌。但整体来看，star数基本保持的500以上。该波动基本符合Kubernetes每3个月发布一次新版本的更新记录，每次版本的更新都会带来star个数的增加。



**Marp每月打开 Issue 和 关闭 Issue 的个数**

![image-20220515144657977](https://raw.githubusercontent.com/dcxr969/OSSDev2022/main/img/202205151449638.png)

**kubernetes每月打开 Issue 和 关闭 Issue 的个数**

![image-20220629190814889](https://raw.githubusercontent.com/dcxr969/picgooo/master/img/202206291908371.png)

**Marp**：2016年7月打开Issue和关闭Issue出现了一个峰值，2018年10月关闭Issue出现了一个峰值，其他时间的打开和关闭Issue个数基本在20以下，2019年9月项目归档后，大量Issue被关闭。可以看出其实长期以来该项目的Issue数量均不是很多。

**kubernetes**：该项目的Issue打开和关闭数量变化分为两个较为明显的阶段。在2015年1月到2018年5月之间，该项目讨论的热度很高，几乎每月都有超过500个Issue被提出，关闭的Issue数量基本随着打开的Issue数量变化，说明绝大多数Issue都得到了解决。2018年2月，大量Issue被关闭。2018年5月之后，打开和关闭的Issue个数基本在400左右波动，关闭的Issue数量基本大于打开的Issue数量。考虑到这个明显的时间节点分水岭，可能是因为项目的稳定性和成熟性上已经达到了一定的高度。



**Marp每月打开PR和合入PR的个数**

![image-20220515144754761](https://raw.githubusercontent.com/dcxr969/OSSDev2022/main/img/202205152124715.png)

**kubernetes每月打开PR和合入PR的个数**

![image-20220629190842824](https://raw.githubusercontent.com/dcxr969/picgooo/master/img/202206291908117.png)

**Marp**：该项目于2016年7月打开PR的最高个数为15，2016年7月和2016年10月合入PR的个数最高，为8左右，2016年 11月之后打开和合入PR的每个月个数基本不超过5个，且经常出现为零的情况，可以看出该项目的开源参与热度不是很高，热度的持续时间也比较短。

**kubernetes**：在2015年1月到2019年10月之间，该项目每个月打开和合入PR的个数基本在500-1000之间波动。2019年10月之后，项目的打开和合入PR个数出现下降趋势，并在2021年10月出现一个小的低谷，这一小的低谷与前面star、fork、issue的变化数量时间上具有一致性。总体可以看出，开源贡献者对该项目的关注度较高。



- 开发者数量（2.4）变化趋势

**Marp每月在仓库中活跃的不同开发者总数**

![image-20220515144946920](https://raw.githubusercontent.com/dcxr969/OSSDev2022/main/img/202205151449244.png)

**kubernetes每月在仓库中活跃的不同开发者总数**

![image-20220629190952759](C:\Users\ymyymyymy\AppData\Roaming\Typora\typora-user-images\image-20220629190952759.png)

**Marp**：该项目的活跃开发者人数呈现出明显的激增和骤降，与2016年7月达到一个峰值，约为3000人左右，之后一直稳定在100人左右，并在2019年3月之后出现持续减少直至归档。

**kubernetes**：该项目的活跃开发者人数一直呈现出上涨的趋势，最高于2019年4月达到3364人，之后稳定在2000人左右，于2021年10月出现一个低点，活跃开发者降至1021人，出现了开发者的流失。



- 其他你感兴趣的对比方向

  **Issue从打开到关闭的平均时长**

  Marp中Issue从打开到关闭的平均时长为557天，kubernetes为160天，可以看出在这一方面，kubernetes对于Issue的解决速度有明显的优势，既是项目人力资源的体现，也是吸引更多开发者的重要因素。

  **PR从打开到合入的平均时长**

  Marp中PR从打开到合入的平均时长为17天，kubernetes为13天，两者在这一方面基本相同，但考虑到Marp项目PR数量较少，而kubernetes的PR数量较多，从而体现出kubernetes项目开发者对PR处理的高效性。

  **Issue和PR从打开到第一次有人回复的平均时长**

  Marp中Issue和PR从打开到第一次有人回复的平均时长为83天，kubernetes为8天，可以看出kubernetes的平均回复时长远短于Marp，从侧面体现出了kubernetes对于Issue和PR的关注度高，从而促进了项目的更新迭代。

  

我认为项目发展到活跃/归档的主要影响因素有以下几点：

1. 市场需要

在实际的生产型应用中会涉及到多个容器跨越多个服务器主机进行部署的情况，其中涉及到容器的部署、拓展和安全性等问题。kubernetes针对这一问题提出了有效的解决方案，实现了构建跨多个容器的应用服务、跨集群调度、扩展这些容器，并长期持续管理这些容器的健康状况。因此，kubernetes抓住了市场需要的风口，极大满足了企业的需要。

2. 项目本身的完整度

Kubernetes 的前身是Google内部的Borg项目，Google 作为最早研发 Linux 容器技术的企业之一，使得Kubernetes项目本身就具有极高的系统性和完整度。Kubernetes 极大推动了云原生领域的发展，被称为影响云计算未来 10 年的技术。

3. 经济资源

Kubernetes项目有大厂背书，诞生在一个云服务供应商的内部，所以一开始就知道它将来会有怎样的发展潜力，应该向什么方向发展，它本身就具有充足的经济资源支撑它的发展。一线大厂与 Kubernetes 可以说是利益共同体，Kubernetes 的成功可以让企业快速推出产品变现，商业成功后反哺社区，进一步繁荣社区。

4. 人力资源

Kubernetes创始于Google，在该项目开源后，RedHat、华为、IBM、微软、VMware等企业迅速加入社区贡献者行列，为Kubernetes提供了丰富的人力资源，众多优秀工程师的加入也促进了Kubernetes的飞速发展。据Kubernetes创始人介绍，在 Kubernetes 项目早期，社区有很多来自不同方向的、伟大的创新想法。他们专注于构建可扩展性的机会，这意味着人们可以构建和扩展 Kubernetes，无需与 Kubernetes 项目本身进行协调。这在很大程度上推动了更广泛生态系统的发展。

6. 项目的设计理念

Kubernetes在设计之初就避免了和Docker Swarm、Apache Mesos等产品的同质化，作为一个以API为中心、面向应用的容器调度平台，它让用户参与到了容器管理的各个阶段，同时也吸引了大量的社区贡献者。Marp项目本身确实具有轻便性、易上手等特性，但在市场的同类型产品较多，不能体现其优越性和创新性。

5. 丰富的社区活动

Kubernetes社区每年都会组织 2~3 场全球性的技术峰会 KubeCon，从历年会议情况来看，会议议题数和参数人数均成爆发式增长态势。除了 KubeCon 这种全球性的峰会外，还有很多自发的 Meetup 活动，比如 Cloud Native Days China、Cloud Native Days India 等。跟据 CNCF 官方统计数据，2017 年各类 Meetup 参会人数为 53925 人，而 2018 年参数人数增长了 60%达到 89112 人。除了线下聚会，还有线上的活动来传播 Kubernetes 相关知识，比如"Cloud Native Lives"。